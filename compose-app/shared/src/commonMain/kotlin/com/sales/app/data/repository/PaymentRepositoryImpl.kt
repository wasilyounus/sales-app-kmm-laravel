package com.sales.app.data.repository

import com.sales.app.data.local.dao.TransactionDao
import com.sales.app.data.local.entity.TransactionEntity
import com.sales.app.data.remote.ApiService
import com.sales.app.data.remote.dto.TransactionRequest
import com.sales.app.domain.model.Transaction
import com.sales.app.domain.repository.PaymentRepository
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.map

class PaymentRepositoryImpl(
    private val apiService: ApiService,
    private val transactionDao: TransactionDao
) : PaymentRepository {

    override fun getTransactions(accountId: Int, page: Int, search: String?): Flow<List<Transaction>> {
        // For now, we only support local caching for the main list without search
        // Ideally we should fetch from API and update DB, then observe DB
        // But for simplicity in this step, we'll just return DB flow and trigger a refresh separately
        // Or better: trigger a refresh and return the flow.
        
        // Since we don't have a refresh mechanism here yet, we'll assume the SyncRepository handles full sync.
        // But for immediate updates, we might want to fetch from API.
        
        // Let's implement a simple fetch-and-cache strategy if needed, but for now just return DB.
        // Wait, the interface returns Flow.
        
        return transactionDao.getTransactions(accountId).map { entities ->
            entities.map { it.toDomain() }
        }
    }

    override suspend fun createTransaction(transaction: Transaction): Result<Unit> {
        return try {
            // Map domain model to request DTO
            // Wait, the domain model 'Transaction' is for reading.
            // For creating, we might need a separate input model or just use params.
            // The repository interface takes 'Transaction'.
            // But 'Transaction' has ID which is generated by backend.
            
            // Let's assume the UI passes a Transaction object with dummy ID.
            // Or we should update the interface to take specific params.
            // For now, let's map what we can.
            
            val request = TransactionRequest(
                date = transaction.date,
                amount = transaction.amount,
                type = if (transaction.isReceived) "received" else "paid",
                method = "cash", // Defaulting to cash for now, need to handle method in domain model
                partyId = if (transaction.isReceived) transaction.debitCode else transaction.creditCode,
                comment = transaction.comment,
                log_id = 0  // Default log_id
            )
            
            apiService.createTransaction(request)
            Result.success(Unit)
        } catch (e: Exception) {
            Result.failure(e)
        }
    }

    private fun TransactionEntity.toDomain(): Transaction {
        return Transaction(
            id = id,
            date = date,
            amount = amount,
            type = type,
            debitCode = debitCode,
            creditCode = creditCode,
            comment = comment,
            partyName = partyName,
            isReceived = isReceived
        )
    }
}
